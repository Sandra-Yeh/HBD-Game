<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>ç”Ÿæ—¥æ ¼é¬¥äº’å‹•éŠæˆ² - å®Œæ•´ç‰ˆ</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
<style>
  body { margin:0; padding:0; background:hsl(6, 100%, 94%); overflow:hidden; }
</style>
</head>
<body>


<script>
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 400,
    backgroundColor: '#ffe4e1',
    parent: 'phaser-example',
    scene: { preload, create, update }
};

const game = new Phaser.Game(config);

let player, enemy;
let cursors, attackKey, specialKey, defendKey;
let playerHP = 10, enemyHP = 10;
let inventory = [];
let attackCooldown = 0, specialCooldown=0, defendCooldown=0;
let messageText, inventoryText, distanceText;
let particles;
let attackRangeCircle, defendRangeCircle;
// å›åˆæ©Ÿåˆ¶
let currentRound = 1;
let inputLocked = false; // å›åˆé–“éš”æ™‚é–å®šæ“ä½œ
let roundText;
let gameEnded = false; // éŠæˆ²çµæŸæ¨™è¨˜
// è¡€æ¢ç›¸é—œ
let playerBarBg, playerBar, enemyBarBg, enemyBar;
const HP_MAX = 10;
const BAR_W = 200;
const BAR_H = 12;
// ç§»å‹•å’Œè·é›¢ç›¸é—œ
let enemySpeed = 3; // å¢åŠ æ•µäººç§»å‹•é€Ÿåº¦
let enemyDirection = 1; // 1 = å‘å³, -1 = å‘å·¦
let enemyMoveTimer = 0;
const ATTACK_RANGE = 150; // æ”»æ“Šç¯„åœ
const DEFEND_RANGE = 120; // é˜²å®ˆç¯„åœ

function preload() {
    console.log('é–‹å§‹è¼‰å…¥åœ–ç‰‡...');
    // è¼‰å…¥èƒŒæ™¯åœ–ç‰‡ï¼ˆè«‹å°‡æª”æ¡ˆæ”¾åœ¨åŒç›®éŒ„ï¼Œä¸¦ä¾éœ€è¦èª¿æ•´æª”å/è·¯å¾‘ï¼‰
    this.load.image('Background', 'img/Background.jpeg');
    this.load.image('player', 'img/player1.png');
    this.load.image('enemy', 'img/player2.png');
    console.log('åœ–ç‰‡è¼‰å…¥è«‹æ±‚å·²ç™¼é€');
    
    // æ·»åŠ è¼‰å…¥éŒ¯èª¤è™•ç†
    this.load.on('loaderror', function(event) {
        console.error('åœ–ç‰‡è¼‰å…¥å¤±æ•—:', event.key, event.file);
        console.log('å°‡ä½¿ç”¨å‚™ç”¨æ–¹æ¡ˆç¹¼çºŒéŠæˆ²');
    });
    
    this.load.on('complete', function() {
        console.log('æ‰€æœ‰åœ–ç‰‡è¼‰å…¥å®Œæˆ');
    });
}

function create() {
    // èƒŒæ™¯åœ–ç‰‡ï¼ˆè¦†è“‹æ•´å€‹ç•«å¸ƒå¤§å°ï¼‰
    console.log('é–‹å§‹å‰µå»ºéŠæˆ²ç‰©ä»¶...');
    
    try {
        const background = this.add.image(400, 200, 'Background');
        background.setDisplaySize(800, 400);
        console.log('èƒŒæ™¯åœ–ç‰‡å‰µå»ºæˆåŠŸ');
    } catch (error) {
        console.error('èƒŒæ™¯åœ–ç‰‡å‰µå»ºå¤±æ•—:', error);
        // å¦‚æœèƒŒæ™¯åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨ç´”è‰²èƒŒæ™¯
        this.add.rectangle(400, 200, 800, 400, 0xffe4e1);
        console.log('ä½¿ç”¨ç´”è‰²èƒŒæ™¯æ›¿ä»£');
    }

    // ç©å®¶èˆ‡æ•µäººï¼ˆå…ˆç”¨æ–¹å¡Šï¼‰
    try {
        player = this.add.image(150,300, 'player');
        player.setDisplaySize(100, 200);
        console.log('ç©å®¶åœ–ç‰‡å‰µå»ºæˆåŠŸ');
    } catch (error) {
        console.error('ç©å®¶åœ–ç‰‡å‰µå»ºå¤±æ•—:', error);
        // å¦‚æœç©å®¶åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨çŸ©å½¢æ›¿ä»£
        player = this.add.rectangle(150, 300, 100, 200, 0x4ecdc4);
        console.log('ä½¿ç”¨çŸ©å½¢æ›¿ä»£ç©å®¶');
    }
    
    try {
        enemy = this.add.image(650,300, 'enemy');
        enemy.setDisplaySize(120, 200);
        console.log('æ•µäººåœ–ç‰‡å‰µå»ºæˆåŠŸ');
    } catch (error) {
        console.error('æ•µäººåœ–ç‰‡å‰µå»ºå¤±æ•—:', error);
        // å¦‚æœæ•µäººåœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨çŸ©å½¢æ›¿ä»£
        enemy = this.add.rectangle(650, 300, 120, 200, 0xe74c3c);
        console.log('ä½¿ç”¨çŸ©å½¢æ›¿ä»£æ•µäºº');
    }
    
    // ç¯„åœæŒ‡ç¤ºå™¨ï¼ˆåŠé€æ˜åœ“åœˆï¼‰
    attackRangeCircle = this.add.circle(0, 0, ATTACK_RANGE, 0xff0000, 0.1).setStrokeStyle(2, 0xff0000, 0.3);
    defendRangeCircle = this.add.circle(0, 0, DEFEND_RANGE, 0x00ff00, 0.1).setStrokeStyle(2, 0x00ff00, 0.3);
    attackRangeCircle.setVisible(false);
    defendRangeCircle.setVisible(false);

    // æ–‡å­—
    const titleX = this.scale.width / 2;
    const titleY = 20;
    messageText = this.add.text(titleX, titleY, 'å¿«æ‰“ç’‡é¢¨', {fontSize:'22px',fill:'#fff',fontStyle:'bold'}).setOrigin(0.5, 0);
    inventoryText = this.add.text(20,80,`é“å…·: ${inventory.join(', ')}`,{fontSize:'18px',fill:'#fff',fontStyle:'bold'});
    distanceText = this.add.text(20, 100, 'è·é›¢: --', {fontSize:'16px',fill:'#fff',fontStyle:'bold'}).setVisible(false);
    
    // æ§åˆ¶èªªæ˜
    this.add.text(20, 350, 'â†â†’ ç§»å‹• | ç©ºç™½éµ æ”»æ“Š | Z å¿…æ®ºæŠ€ | X é˜²å®ˆ', {fontSize:'14px',fill:'#fff',fontStyle:'bold'});
    this.add.text(20, 370, 'ç´…è‰²ç¯„åœ: æ”»æ“Šç¯„åœ | ç¶ è‰²ç¯„åœ: é˜²å®ˆç¯„åœ', {fontSize:'12px',fill:'#fff',fontStyle:'bold'});

    // è¡€æ¢ï¼ˆç©å®¶å·¦ã€æ•µäººå³ï¼‰
    playerBarBg = this.add.rectangle(20, 50, BAR_W, BAR_H, 0x000000, 0.2).setOrigin(0, 0.5);
    playerBar   = this.add.rectangle(20, 50, BAR_W, BAR_H, 0x2ecc71).setOrigin(0, 0.5);
    enemyBarBg  = this.add.rectangle(800 - 20 - BAR_W, 50, BAR_W, BAR_H, 0x000000, 0.2).setOrigin(0, 0.5);
    enemyBar    = this.add.rectangle(800 - 20 - BAR_W, 50, BAR_W, BAR_H, 0xe74c3c).setOrigin(0, 0.5);

    // æ§åˆ¶
    cursors = this.input.keyboard.createCursorKeys();
    attackKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    specialKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
    defendKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);

    // ç²’å­ç³»çµ± (æ”»æ“Š/ç…™ç«)
    // ç”Ÿæˆä¸€å€‹ç°¡å–®çš„ç´…è‰²ç²’å­æè³ªï¼Œé¿å…ç¼ºå°‘è²¼åœ–
    const g = this.add.graphics();
    g.fillStyle(0xff0000, 1);
    g.fillCircle(4, 4, 4);
    g.generateTexture('red', 8, 8);
    g.destroy();
    particles = this.add.particles('red');

    // å›åˆé–‹å§‹æç¤º
    showRound(this, currentRound);
}

function update(time, delta) {
    // å¦‚æœéŠæˆ²å·²çµæŸï¼Œåœæ­¢æ‰€æœ‰æ›´æ–°
    if(gameEnded) {
        console.log('éŠæˆ²å·²çµæŸï¼Œåœæ­¢æ›´æ–°');
        return;
    }
    
    let speed=3;
    attackCooldown -= delta;
    specialCooldown -= delta;
    defendCooldown -= delta;
    enemyMoveTimer -= delta;

    // è¨ˆç®—è·é›¢
    const distance = Math.abs(player.x - enemy.x);

    // ç©å®¶ç§»å‹•
    if(!inputLocked && cursors.left.isDown) player.x -= speed;
    if(!inputLocked && cursors.right.isDown) player.x += speed;

    // æ•µäººç§»å‹•é‚è¼¯
    if(!inputLocked) {
        if(enemyMoveTimer <= 0) {
            // éš¨æ©Ÿæ”¹è®Šæ–¹å‘
            enemyDirection = Math.random() < 0.5 ? -1 : 1;
            enemyMoveTimer = 1000 + Math.random() * 2000; // 1-3ç§’é–“éš”
        }
        
        // æ•µäººç§»å‹•
        enemy.x += enemyDirection * enemySpeed;
        
        // é‚Šç•Œæª¢æŸ¥
        if(enemy.x < 100) enemy.x = 100;
        if(enemy.x > 700) enemy.x = 700;
    }

    // è·é›¢æª¢æ¸¬å’Œæ”»æ“Š
    const canAttack = distance <= ATTACK_RANGE;
    const canDefend = distance <= DEFEND_RANGE;
    
    // æ›´æ–°ç¯„åœæŒ‡ç¤ºå™¨ä½ç½®å’Œå¯è¦‹æ€§
    if(attackRangeCircle) {
        attackRangeCircle.setPosition(player.x, player.y);
        attackRangeCircle.setVisible(canAttack);
    }
    if(defendRangeCircle) {
        defendRangeCircle.setPosition(player.x, player.y);
        defendRangeCircle.setVisible(canDefend);
    }

    // æ™®é€šæ”»æ“Šï¼ˆéœ€è¦è¿‘è·é›¢ï¼‰
    if(!inputLocked && Phaser.Input.Keyboard.JustDown(attackKey) && attackCooldown<=0) {
        if(canAttack) {
            attackCooldown=500;
            console.log(`æ”»æ“Šå‰æ•µäººè¡€é‡: ${enemyHP}`);
            enemyHP -=2;
            console.log(`æ”»æ“Šå¾Œæ•µäººè¡€é‡: ${enemyHP}`);
            messageText.setText('ä½ æ”»æ“Šäº†æ•µäººï¼æ•µäººæ‰ 2 HP');
            createParticles(enemy.x,enemy.y,15);
        } else {
            messageText.setText('è·é›¢å¤ªé ï¼é è¿‘æ•µäººæ‰èƒ½æ”»æ“Šï¼');
        }
    }

    // å¿…æ®ºæŠ€ï¼ˆéœ€è¦è¿‘è·é›¢ï¼‰
    if(!inputLocked && Phaser.Input.Keyboard.JustDown(specialKey) && specialCooldown<=0) {
        if(canAttack) {
            specialCooldown=2000;
            enemyHP -=4;
            messageText.setText('ä½ ä½¿å‡ºå¿…æ®ºæŠ€ï¼æ•µäººæ‰ 4 HP ğŸ’¥');
            createParticles(enemy.x,enemy.y,30);
        } else {
            messageText.setText('è·é›¢å¤ªé ï¼é è¿‘æ•µäººæ‰èƒ½ä½¿ç”¨å¿…æ®ºæŠ€ï¼');
        }
    }

    // é˜²å®ˆï¼ˆéœ€è¦è¿‘è·é›¢ï¼‰
    if(!inputLocked && Phaser.Input.Keyboard.JustDown(defendKey) && defendCooldown<=0) {
        if(canDefend) {
            defendCooldown=1000;
            messageText.setText('ä½ é€²å…¥é˜²å®ˆå§¿æ…‹ï¼æ¸›å°‘å‚·å®³ï¼');
            createParticles(player.x,player.y,10);
        } else {
            messageText.setText('æ•µäººå¤ªé ï¼ç„¡æ³•é˜²å®ˆï¼');
        }
    }

    // æ•µäººæ”»æ“Šï¼ˆåªæœ‰è¿‘è·é›¢æ™‚æ‰æœƒæ”»æ“Šï¼‰- å¢å¼·ç‰ˆ
    const attackChance = currentRound === 1 ? 0.008 : 0.012; // ç¬¬äºŒå›åˆæ”»æ“Šæ›´é »ç¹
    
    if(!inputLocked && distance <= ATTACK_RANGE && Math.random() < attackChance) {
        // æ ¹æ“šå›åˆæ•¸å¢åŠ å‚·å®³
        const baseDamage = currentRound === 1 ? 1 : 2; // ç¬¬äºŒå›åˆåŸºç¤å‚·å®³æ›´é«˜
        
        let damage;
        const rand = Math.random();
        
        if(rand < 0.2) {
            damage = baseDamage + 3; // 20%æ©Ÿç‡é€ æˆé‡æ“Š
        } else if(rand < 0.5) {
            damage = baseDamage + 2; // 30%æ©Ÿç‡é€ æˆä¸­æ“Š
        } else {
            damage = baseDamage + 1; // 50%æ©Ÿç‡é€ æˆè¼•æ“Š
        }
        
        playerHP -= damage;
        
        // æ ¹æ“šå‚·å®³å’Œå›åˆé¡¯ç¤ºä¸åŒçš„è¨Šæ¯
        let attackMessage;
        if(damage >= 5) {
            attackMessage = `æ•µäººé‡æ“Šä½ ï¼ä½ æ‰ ${damage} HP ğŸ’¥`;
        } else if(damage >= 4) {
            attackMessage = `æ•µäººå¼·åŠ›æ”»æ“Šä½ ï¼ä½ æ‰ ${damage} HP âš¡`;
        } else if(damage >= 3) {
            attackMessage = `æ•µäººæ”»æ“Šä½ ï¼ä½ æ‰ ${damage} HP`;
        } else {
            attackMessage = `æ•µäººè¼•æ“Šä½ ï¼ä½ æ‰ ${damage} HP`;
        }
        
        // ç¬¬äºŒå›åˆçš„ç‰¹æ®Šè¨Šæ¯
        if(currentRound >= 2) {
            attackMessage += " (Round 2 å¼·åŒ–!)";
        }
        
        messageText.setText(attackMessage);
        createParticles(player.x,player.y,15);
    }

    // æ›´æ–°è¡€æ¢å¯¬åº¦
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    playerBar.displayWidth = BAR_W * clamp(playerHP, 0, HP_MAX) / HP_MAX;
    enemyBar.displayWidth  = BAR_W * clamp(enemyHP, 0, HP_MAX) / HP_MAX;

    // å‹åˆ©åˆ¤æ–·
    if(enemyHP<=0){
        // é˜²æ­¢é‡è¤‡åŸ·è¡Œå‹åˆ©é‚è¼¯
        if(inputLocked) {
            console.log('å‹åˆ©é‚è¼¯è¢«è·³éï¼ŒinputLocked = true');
            return;
        }
        
        console.log(`æ•µäººè¡€é‡æ­¸é›¶ï¼Œç•¶å‰å›åˆ: ${currentRound}, inputLocked: ${inputLocked}`);
        
        // ç«‹å³é–å®šè¼¸å…¥ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
        inputLocked = true;
        
        // ç²å¾—é“å…·é‚è¼¯
        let items = ['ğŸ','ğŸª„'];
        let item = items[Math.floor(Math.random()*items.length)];
        inventory.push(item);
        inventoryText.setText(`é“å…·: ${inventory.join(', ')}`);
        messageText.setText(`ä½ æ‰“æ•—äº†æ•µäººï¼ç²å¾—é“å…· ${item}`);
        
        console.log(`ç²å¾—é“å…·: ${item}, ç›®å‰é“å…·: ${inventory.join(', ')}`);
        
        // é‡ç½®æ•µäººè¡€é‡
        enemyHP = 10;

        // å›åˆæ¨é€²èˆ‡é–“éš”
        console.log(`ç•¶å‰å›åˆ: ${currentRound}`);
        if(currentRound < 2){
            currentRound += 1;
            console.log(`é€²å…¥ä¸‹ä¸€å›åˆ: ${currentRound}`);
            // å»¶é²å•Ÿå‹•ä¸‹ä¸€å›åˆï¼Œç¢ºä¿é“å…·é¡¯ç¤ºæ¸…æ¥š
            this.time.delayedCall(1500, () => {
                startIntermission(this);
            });
        } else {
            // Round 2 çµæŸï¼Œæº–å‚™çµå±€
            console.log('Round 2 çµæŸï¼Œæº–å‚™é¡¯ç¤ºçµå±€');
            
            // å»¶é² 2 ç§’å¾Œé¡¯ç¤ºçµå±€ï¼Œç¢ºä¿æ‰€æœ‰ç‹€æ…‹ç©©å®š
            this.time.delayedCall(2000, () => {
                console.log('é–‹å§‹é¡¯ç¤ºçµå±€ï¼Œç•¶å‰é“å…·:', inventory);
                gameEnded = true; // åœ¨çµå±€é¡¯ç¤ºæ™‚æ‰æ¨™è¨˜éŠæˆ²çµæŸ
                showEnding(this);
            });
        }
        return; // è·³å‡º update å‡½å¼ï¼Œé¿å…é‡è¤‡åŸ·è¡Œ
    }

    // ç©å®¶æ­»äº¡
    if(playerHP<=0){
        messageText.setText('ä½ è¢«æ‰“æ•—äº†ï¼Œé‡æ–°æˆ°é¬¥ ğŸ’€');
        playerHP = 10;
        enemyHP = 10;
        inputLocked = false; // é‡æ–°é–‹å§‹æˆ°é¬¥
    }
}

function createParticles(x,y,count){
    let emitter = particles.createEmitter({
        x:x, y:y,
        speed:{min:100,max:200},
        angle:{min:0,max:360},
        lifespan:400,
        quantity:count,
        scale:{start:0.5,end:0},
    });
    emitter.explode(count,x,y);
}

function showEnding(scene){
    console.log('showEnding è¢«èª¿ç”¨ï¼Œé“å…·åˆ—è¡¨:', inventory);
    
    // ç¢ºä¿è¼¸å…¥å®Œå…¨é–å®šå’ŒéŠæˆ²çµæŸ
    inputLocked = true;
    gameEnded = true;
    
    // éš±è—ç©å®¶å’Œæ•µäºº
    if(player) player.setVisible(false);
    if(enemy) enemy.setVisible(false);
    
    // éš±è—ç¯„åœæŒ‡ç¤ºå™¨
    if(attackRangeCircle) attackRangeCircle.setVisible(false);
    if(defendRangeCircle) defendRangeCircle.setVisible(false);
    
    // éš±è—æ‰€æœ‰ UI å…ƒç´ 
    if(messageText) messageText.setVisible(false);
    if(inventoryText) inventoryText.setVisible(false);
    if(distanceText) distanceText.setVisible(false);
    if(playerBarBg) playerBarBg.setVisible(false);
    if(playerBar) playerBar.setVisible(false);
    if(enemyBarBg) enemyBarBg.setVisible(false);
    if(enemyBar) enemyBar.setVisible(false);
    
    // éš±è—æ§åˆ¶èªªæ˜æ–‡å­—
    const controlTexts = scene.children.list.filter(child => 
        child.type === 'Text' && 
        (child.text.includes('â†â†’ ç§»å‹•') || child.text.includes('ç´…è‰²ç¯„åœ'))
    );
    controlTexts.forEach(text => text.setVisible(false));
    
    // åœæ­¢æ‰€æœ‰ç²’å­æ•ˆæœ
    if(particles) {
        particles.destroy();
        particles = null;
    }
    
    // æ¸…ç†å›åˆæ–‡å­—
    if(roundText) {
        roundText.destroy();
        roundText = null;
    }
    
    let endingMsg='';
    console.log('æª¢æŸ¥é“å…·:', inventory);
    console.log('é“å…·æ•¸é‡:', inventory.length);
    console.log('ğŸ æ•¸é‡:', inventory.filter(i => i === 'ğŸ').length);
    console.log('ğŸª„ æ•¸é‡:', inventory.filter(i => i === 'ğŸª„').length);
    
    // ä¿®å¾©çµå±€é‚è¼¯ - ç¢ºä¿èƒ½æ­£ç¢ºåˆ¤æ–·
    console.log('é–‹å§‹çµå±€åˆ¤æ–·é‚è¼¯...');
    if(inventory.length >= 2) {
        console.log('é“å…·æ•¸é‡è¶³å¤ ï¼Œé–‹å§‹åˆ†æé“å…·é¡å‹...');
        const giftCount = inventory.filter(i => i === 'ğŸ').length;
        const magicCount = inventory.filter(i => i === 'ğŸª„').length;
        
        if(giftCount >= 1 && magicCount >= 1) {
            // æ··åˆé“å…· - é¡¯ç¤ºè½‰ç›¤
            console.log('é¡¯ç¤ºçµå±€C - è½‰ç›¤ï¼ˆæ··åˆé“å…·ï¼‰');
            showRoulette(scene);
            return;
        } else if(giftCount >= 1) {
            // ä¸»è¦æ˜¯ç¦®ç‰©
            endingMsg="âœ¨ çµå±€A: ç”Ÿæ—¥ç¦®ç‰©é¸é …1ï¼";
            console.log('é¡¯ç¤ºçµå±€A - ç¦®ç‰©');
        } else if(magicCount >= 1) {
            // ä¸»è¦æ˜¯é­”æ³•
            endingMsg="ğŸª„ çµå±€B: ç”Ÿæ—¥ç¦®ç‰©é¸é …2ï¼";
            console.log('é¡¯ç¤ºçµå±€B - é­”æ³•');
        } else {
            // é è¨­è½‰ç›¤
            console.log('é¡¯ç¤ºçµå±€C - è½‰ç›¤ï¼ˆé è¨­ï¼‰');
            showRoulette(scene);
            return;
        }
    } else {
        // é“å…·ä¸è¶³ï¼Œé¡¯ç¤ºè½‰ç›¤
        console.log('é“å…·ä¸è¶³ï¼Œé¡¯ç¤ºè½‰ç›¤');
        showRoulette(scene);
        return;
    }

    // ç…™ç«ç²’å­
    let firework = scene.add.particles('red');
    let fwEmitter = firework.createEmitter({
        x:400, y:200,
        speed:{min:100,max:300},
        angle:{min:0,max:360},
        lifespan:800,
        quantity:30,
        scale:{start:0.8,end:0},
    });
    fwEmitter.explode(50,400,200);

    // çµå±€è¨Šæ¯ - ä½¿ç”¨ h1 å¤§å°çš„å­—é«”
    console.log('æº–å‚™é¡¯ç¤ºçµå±€è¨Šæ¯:', endingMsg);
    const centerX = scene.scale.width / 2;
    const centerY = scene.scale.height / 2;
    const endingText = scene.add.text(centerX, centerY, endingMsg, {
        fontSize:'56px',
        fill:'#fff',
        fontStyle:'bold',
        stroke:'#000',
        strokeThickness:4,
        align:'center'
    }).setOrigin(0.5, 0.5);
    
    console.log('çµå±€æ–‡å­—å·²å‰µå»º:', endingText.text);
}

 // ---- è½‰ç›¤åŠŸèƒ½ ----
 function showRoulette(scene){
     // çé …è¨­å®š
     const prizes = ['10å…ƒ', '10å…ƒ', '50å…ƒ', '100å…ƒ', '500å…ƒ'];
     const colors = [0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff]; // ç´”ç™½è‰²
    
    // æ¨™é¡Œ
    scene.add.text(400, 50, 'ğŸ° éš¨æ©Ÿçé‡‘è½‰ç›¤ ğŸ°', {
        fontSize:'32px',
        fill:'#fff',
        fontStyle:'bold',
        stroke:'#000',
        strokeThickness:3
    }).setOrigin(0.5, 0.5);
    
    // è½‰ç›¤å®¹å™¨
    const centerX = 400;
    const centerY = 200;
    const radius = 120;
    
    // å‰µå»ºè½‰ç›¤å®¹å™¨
    const rouletteContainer = scene.add.container(centerX, centerY);
    
    // ç¹ªè£½è½‰ç›¤æ‰‡å½¢
    const graphics = scene.add.graphics();
    const angleStep = (Math.PI * 2) / prizes.length;
    
    prizes.forEach((prize, index) => {
        const startAngle = index * angleStep - Math.PI / 2;
        const endAngle = (index + 1) * angleStep - Math.PI / 2;
        
        // æ‰‡å½¢èƒŒæ™¯
        graphics.fillStyle(colors[index], 0.8);
        graphics.slice(0, 0, radius, startAngle, endAngle, true);
        graphics.fillPath();
        
        // æ‰‡å½¢é‚Šæ¡†
        graphics.lineStyle(3, 0x000000, 1);
        graphics.slice(0, 0, radius, startAngle, endAngle, true);
        graphics.strokePath();
        
        // æ–‡å­—
        const textAngle = startAngle + angleStep / 2;
        const textX = Math.cos(textAngle) * (radius * 0.7);
        const textY = Math.sin(textAngle) * (radius * 0.7);
        
        const textObj = scene.add.text(textX, textY, prize, {
            fontSize:'18px',
            fill:'#000',
            fontStyle:'bold',
            stroke:'#fff',
            strokeThickness:2
        }).setOrigin(0.5, 0.5);
        
        rouletteContainer.add(textObj);
    });
    
    // å°‡åœ–å½¢æ·»åŠ åˆ°å®¹å™¨
    rouletteContainer.add(graphics);
    
    // ä¸­å¿ƒæŒ‡é‡ï¼ˆå›ºå®šï¼Œä¸æ—‹è½‰ï¼‰
    const pointer = scene.add.graphics();
    pointer.fillStyle(0xff0000, 1);
    pointer.fillTriangle(0, -20, -10, 10, 10, 10);
    pointer.fillPath();
    pointer.setPosition(centerX, centerY);
    
     // è½‰å‹•ç‹€æ…‹æ–‡å­—
     const spinningText = scene.add.text(400, 350, 'è½‰å‹•ä¸­...', {
         fontSize:'24px',
         fill:'#ffd700',
         fontStyle:'bold',
         stroke:'#000',
         strokeThickness:3
     }).setOrigin(0.5, 0.5);
     
     // å¯ç²å¾—é‡‘é¡æç¤º
     const availableText = scene.add.text(400, 320, 'å¯ç²å¾—ï¼š10å…ƒã€50å…ƒã€100å…ƒã€500å…ƒ', {
         fontSize:'16px',
         fill:'#fff',
         fontStyle:'bold',
         stroke:'#000',
         strokeThickness:2
     }).setOrigin(0.5, 0.5);
     
     // è½‰ç›¤æ—‹è½‰å‹•ç•«
     const targetRotation = Math.random() * 20 + 10; // 10-30åœˆ
     const spinDuration = 3000; // 3ç§’
     
     const spinTween = scene.tweens.add({
         targets: rouletteContainer,
         rotation: targetRotation * Math.PI * 2,
         duration: spinDuration,
         ease: 'Power2.easeOut',
         onUpdate: () => {
             // è½‰å‹•æ™‚æ›´æ–°æ–‡å­—æ•ˆæœ
             const progress = spinTween.progress;
             if (progress < 0.9) {
                 spinningText.setText(`è½‰å‹•ä¸­... ${Math.floor(progress * 100)}%`);
             }
         },
         onComplete: () => {
             // è¨ˆç®—æœ€çµ‚çµæœ
             const finalRotation = rouletteContainer.rotation % (Math.PI * 2);
             const adjustedAngle = (finalRotation + Math.PI / 2) % (Math.PI * 2);
             if (adjustedAngle < 0) adjustedAngle += Math.PI * 2;
             
             const prizeIndex = Math.floor(adjustedAngle / angleStep) % prizes.length;
             const selectedPrize = prizes[prizeIndex];
             
             // ç°¡å–®çš„é«˜äº®æ•ˆæœï¼šåœ¨å¾—çæ‰‡å½¢ä¸Šæ·»åŠ ä¸€å€‹åŠé€æ˜åœ“åœˆ
             const highlightAngle = prizeIndex * angleStep - Math.PI / 2 + angleStep / 2;
             const highlightX = Math.cos(highlightAngle) * (radius * 0.5);
             const highlightY = Math.sin(highlightAngle) * (radius * 0.5);
             
             const highlightCircle = scene.add.circle(highlightX, highlightY, radius * 0.3, 0xffffcc, 0.6);
             highlightCircle.setPosition(centerX + highlightX, centerY + highlightY);
             
             // éš±è—è½‰å‹•æç¤º
             spinningText.destroy();
             availableText.destroy();
             
             // é¡¯ç¤ºå¾—ççµæœ
             const resultText = scene.add.text(400, 320, `ğŸ‰ æ­å–œç²å¾—ï¼š${selectedPrize} ğŸ‰`, {
                 fontSize:'32px',
                 fill:'#ffd700',
                 fontStyle:'bold',
                 stroke:'#000',
                 strokeThickness:4
             }).setOrigin(0.5, 0.5);
             
             // æ·»åŠ é–ƒçˆæ•ˆæœ
             scene.tweens.add({
                 targets: resultText,
                 alpha: 0.3,
                 duration: 500,
                 yoyo: true,
                 repeat: 3,
                 ease: 'Sine.easeInOut'
             });
             
             // ç…™ç«æ•ˆæœ
             let firework = scene.add.particles('red');
             let fwEmitter = firework.createEmitter({
                 x:400, y:200,
                 speed:{min:100,max:300},
                 angle:{min:0,max:360},
                 lifespan:800,
                 quantity:30,
                 scale:{start:0.8,end:0},
             });
             fwEmitter.explode(50,400,200);
         }
     });
}

// ---- å›åˆæç¤ºèˆ‡é–“éš” ----âˆ«
function showRound(scene, round){
    inputLocked = true;
    if(roundText) roundText.destroy();
    const cx = scene.scale.width / 2;
    const cy = scene.scale.height / 2;
    roundText = scene.add.text(cx, cy, `Round ${round}`, { fontSize:'36px', fill:'#fff', fontStyle:'bold' }).setOrigin(0.5);
    scene.time.delayedCall(1200, ()=>{
        inputLocked = false;
        roundText.destroy();
    });
}

function startIntermission(scene){
    console.log(`startIntermission è¢«èª¿ç”¨ï¼Œç•¶å‰å›åˆ: ${currentRound}`);
    inputLocked = true;
    if(roundText) roundText.destroy();
    const cx = scene.scale.width / 2;
    const cy = scene.scale.height / 2;
    roundText = scene.add.text(cx, cy, `Round ${currentRound}`, { fontSize:'36px', fill:'#fff', fontStyle:'bold' }).setOrigin(0.5);
    // çŸ­æš«é–“éš” 1.2 ç§’
    scene.time.delayedCall(1200, ()=>{
        console.log(`å›åˆé–“éš”çµæŸï¼Œè§£é–è¼¸å…¥ï¼Œç•¶å‰å›åˆ: ${currentRound}`);
        inputLocked = false;
        roundText.destroy();
        // ç¢ºä¿éŠæˆ²æœªçµæŸæ‰è§£é–
        if(!gameEnded) {
            messageText.setText('æ–°å›åˆé–‹å§‹ï¼');
        }
    });
}
</script>

</body>
</html>
